// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+x9e28cN/LgVyHmfsDauWnJcR64GFj84LVjxFhn17CcLHBR7pbTXTPDqIfskGxJE5++",
	"+4FVZDe7mz0PaSTbm/nL1jQfRbJY7yp+mORqVSkJ0prJsw+Timu+Agsa/+J5rmppM1G4vwowuRaVFUpO",
	"noVvzFgt5GIynQj3a8XtcjKdSL6Cto3rP51o+L0WGorJM6trmE5MvoQVdwPbdeVa+5FubqYTXhQajBnO",
	"+k9ZrpmQeVkXwKzm0vDcfTLsStgls0thmO/MhGRKAlNzZpedxmwuoCzMSQD69xr0OoLaTz4O4nRynfFy",
	"oTSXRTZXesXt5Nnkue93s/WznyHTqoThGl+o1UxICCuCZkHN4TCrWAFzbLTkljno3DpDQ6uYAa7zJZsr",
	"vWWZBES8VpD1avLsl4kBWYDGk8tBXOJ/5xrgD8gs1wuwk1+nqbObW9CZFavE0l77k9Ng6tIahm1xjQtx",
	"CZK5Xifsx9pYNgPGJXv36gX76quvvmO0jRYKj3Cjq2pnj9fUnELBLYTPuxzqu1cvcP4zv8BdW/GqKkXO",
	"3bqT1+d5+529fjm2mO4gCYQU0sICNG28MZC+q8/dlw3ThI7bJqjtMnNoM36w/sYblis5F4taQ+GwsTZA",
	"d9NUIAshF+wC1qNH2ExzfzdwBnOlYUcspcYHRdN4/o+Kp3mtNch8nS00cLw6Sy6HW/LOb4VZqros2JJf",
	"4rr5CnmA78tcXzrnS17WbotErtXzcqEM434HC5jzurQsTMxqWTqa5UbzeMiEYZVWl6KAYurI+NVS5EuW",
	"c0NDYDt2JcrSbX9toBjb5vTqtqB508nBdav9wAV9upvRrmvLTsA1XoTh8r+/9te9KIT7iZdMWFgZZup8",
	"ybjxUC1V6S67mbKIkrFS5bxkBbecGaschZgr7Vk3kY+p799KIyzHAyzYbN1vKYvO6Nv7uP2B66pUbmVz",
	"XhpI71dYfbxJuMqYSfKynHjS6yQGP2XW/MCrymS44sxYbiFuU1WuhVQSEpy0+YFrzdfub2PXTlxAGjFp",
	"TyfLS2Ugs2qLJBGEA9ywiPfHO7aXXMHeL4Hh5O4DyVSI2dKRm7JcM+sPwCEEC1LElIk5W6uaXeHVKcUF",
	"9vercTi9Yu7w8cg6Io+TG8eQe7AZCdSeKVUCl4jaXobM3PmNc7My4DU1d4wLJygaRjdlBZSAi2yREH81",
	"Vqs1Lt6hwpSpyh26qu3wcsjCD0uf+3cFEWdUXI1XsmXRpVgJO1zuj/xarOoVk/VqBtodeOB8VjENttYS",
	"D1sDy/HMZp2bX/EFGAaOMQqStXEeR7ikskwDz5fjVIlg2kKIVvw606qWxQ4ipWVKxyzbVJCLuYCCNaOM",
	"wdJOsw0eIfeDpxV0I3DCIKPgNLNsAUfCdeJY3fV0X/CAolM9YT953oFfrboA2bAYIpbAKg2XQtWm6TQC",
	"I069WZmTykJWaZiL6yGQZ347HIWgNp7Brbx0lStpuZBQON6HQCsLRG1GYYom3FeEnHED3349Jj+1XzVc",
	"wDpJdPsIQMtpdNal+0J9N6+imWHLpd4RD4nHxvi3Efd2wjtslBHZSMhI7qsnKmn7QKf/DhaCeG7STrM7",
	"WQpojMDexraiN9P9KSVGLDIacXBLxOK948VzUSKf/s1djnCytXF8qXu2gXMbsZDc1hqencsv3F8sY2eW",
	"y4Lrwv2yop9+rEsrzsTC/VTST2/UQuRnYjG2KQHWpOUAu63oHzde2lJgr5vlpqYIn1MzVNw1vIC1BjcH",
	"z+f4z/UcEYnP9R8ke5VjM6fU5DdKXdRVvJN5x2w0W7PXL8ewBIfcRAiRaJhKSQOIrs9Jgnjnf3M/OVoH",
	"Ekl5JASc/mYUqiDt2JVWFWgrIDbTuf/+l4b55Nnkf5y2Zr1T6mZO/YSt1mfHeBjdXG497SKa5akZSQGr",
	"qrbE01NkobnHvzSw9edsj0XNfoPc0gZ1wXgEq8quHzuAPezmcLtlOuL8jvvWF8nvcR+Jq2fInYcj/2S8",
	"2lTxhZC48Cm7WoJkK37hyAGXyi5BM3cWYGzg70T3iOU39kUvJHhJ+2SSujGJMzV3PtT21N44OfcM5dxD",
	"HHFP6drjrFMgHU++OfnBxh4SBRYHOvuNhtfz8194VYni+vz8146qJWQB1+nzuNfDLtUiK7jlt8PRxUvX",
	"NYGgnzIOdY3ah0KgwyLPHqfwsBz1UNt14Mt2Kxp7pKyJW3F3omoM2L/xksv8IOx05ofa+YR/FFIgED+Q",
	"jet4zOGYm608xBH73T3IRSZ79c5X+Hi4qTvceAHufLSHOtKdDvKBNUKc8hCb9LEQ/4jxh8X4v5Uqv7jV",
	"WW46Khx1y8zfa630AbAoyO+9VU8nKzCGLyBtGI93MjTcZesCwHjs4JaA5sMfgJd2+WIJ97CZ0dhbtvR9",
	"azA7wMbe67WKbHvb1h+taotA3h12z5sQTWM+9d37dIhSZ8t3p+WdM+1T9N3P2Ox3yDfBRhwbgRMhWz68",
	"UkjyFAgl3UlxH4FEvptzeS5fwlxIdMU+O5eODp3OuBG5Oa0NaK8EnCwUe8b8kC+55edyMu0zwjFHCgaZ",
	"eGiqelaKnF3AOnUKFP2SNrmUC3V+/iuzyvIycjRHMTHevdcajIcoRxNkDjNUbTMfS5ZpuOK6SIBuGuci",
	"jkzBOZtmnTI/NvlAfayaHz99DQYBHiMWp7JnbzKJOBghu4Eq7nz/oaz3GvIrRvjFagOG/XvFq1+EtL+y",
	"7Lx+8uQrYM+rqjVa/ruNqnFAo9vioBZQXDieZwbXVvMM4wCSy7fAKzz9JTBTrzCkpCwZdusG72i10Hzl",
	"Qwr6YUEbDoDg2I2XRSvExZ1Rr5tpJAwOT9B9wiPENmwJ5TCwaN/zirSoWx/XFk1sQ8zm+fkvGI4ZTqYJ",
	"EFpwIU3gCkYspLsEPtJtBix3UgAUJ+z1nCFVm3a6+3hrTzEb0iEMBaex926N6PlmOZcYtFYVGCYkJONy",
	"3Xe5GbA2ODjfwQWs30eO8z0dsD7Khm9hiUXthmvYYnvC7IobtlLofM1B2nLtA3cSqJkGphbSUgRBJwxs",
	"hGjgrYnis9zFiUnISIRbFK7Eq4otSjXzlKZB0WcNjoY+40TlrQPAHICgJBWnbsRceiO4TmwEXcSxIL/9",
	"F+rGu9M13Li8W6PcXGiDQWHAPY/g8RW5Beb5iLUhKP9aAkplSmPkVhelTLjSKaRvAlKmk4prK3JR7WZF",
	"p9Hfdvq4Qbax9iQzV/M+zx6w1CQLocbZjJs0+wb3xWFgbSia0a0xELowE0nLuIIThtEn/qrOSgxwbELj",
	"6Yy5xsjLsGwKFR8DLX0vQMtWpgpgdHckFt6W3IQgTIwkDiRiJzFnBHnfuw1ABHb3JsLeWG4Vbt4SLvnY",
	"/o8HvryWhaMdYLoBqU1YS2Arw7jgED9GKUAh/CXEvIRAF/evw/a6LJmYs1peSHXlhON9QlmmEyf51elD",
	"UhIlP3fnFrQd1Digjwf4LyY6NgfVP+fzUkhgGRPNHljcAwr6Vrmg2Nr2fvo5wCkGXzCHg26AnUdIIXcE",
	"dqVUSQOzf6j4xsrFPkBKEEhjeBgbiU30N6Q1PBTwUNajQFoh09iYB7rgJMwOs0TAMFJ/BiApHpcJOWVO",
	"z7vkpZNWrCLhpRkkHbf+qCNqezHPPB6T49PWB1oRcrG91kR87zariYXFAHRakt0A8Wa5JXUEBveLpIh2",
	"rzZE52+dekRWGNurR7jwOwDQN3s2oYBe5d2qmg45Wkvap22wJZGRNLaPYUzyXEZ2bGipaEKr3vbZdtIe",
	"0WnFqMnM69eReJYiye5W5EoakKbGlBarclWeDAwRBkpAySbrSBLZBazTOgwggT0L3SIjBXsk5k6leByJ",
	"LhoWwljopJ00kbBtoO8aUzUqbi1oN9H/efTfz355nv1vnv3xJPvuf57++uHrm8dfDH58evPXv/6/7k9f",
	"3fz18X//12SEa0BWaaXm46uzlZ679b1TqqHK2JFhx84yH3wFl8pChgJqdsnLkXAb1+iVQeX5FcqySYGh",
	"c9iMsqbEiOkRp72AdVaIsk7jq5/37y/dtP9o7E2mnl3AGsVC4PmSzbjNlyg3dqZ3bTZMXfKtC35DC37D",
	"D7be3W6Da+om1g5dunN8JveiR2s3kYMEAqaQY3hqo1u6gUAiq38JJXl6xrN56XIWruHJJivr4DIVYexN",
	"ClMExThXopGSa+kGOI2vAqPhMDNJ2CgNywxWtKuCi9Z/4gfRNFe80eDvXZGNVxcrs36UtDbrP95hecPh",
	"d13eocIX8fT2sdOQpDRAMLw4frAtyBWZjofJDE5IDuZvui2RqkC5ijJe2/Aatdlyux1MEEF88p6qG1ba",
	"m+beEBASqgStPYWLbK7VCm/eUCiNkFOMaOQdFGxZTm9WXxtiiC+OeGLO8lYPGvDy77D+2bXFU3W9g2C6",
	"65VpDRRBh/Fqy92O5m6+gBTm+xG3Yj6F5I6hPVYRIINsx7e35w0o1SJtbygXKHeoRZvyFaPDDJzuB9eQ",
	"17bN9uvZExuT58NKk33baTpLJ3LbUkmLzfIDbpQfa8vRvW3o5H2eHK8qrS55mXln1xiN1+rS03hsHnxj",
	"DyyOpa/Z+++fv3nrwUe3CnCdNerM6KqwXfXZrMrJJUqPkNiQEr/ktrEk9Pm/d3YJ03GQXWEmdU9jdpKW",
	"Ry4i0K3zM7q93mE2D3L5nu4v76elJW7w10LVuGtbOzt5a7seWn7JRRkM3AHaNFOhxbU+8r35SjzAnT29",
	"kcM+OyinGNzu9O3YQoniGTakTK8ocd8w5VOjGz0XlVu0liOCrvja4Q2ZJ4ckSdarzF26zJQiT7tA5Mw4",
	"lJDkvXeNGTYeUZPdiI4Xp8eqRTSWa2Z2MLr1gIzmSG5miH4d27uZ8uFFtRS/18BEAdK6TxrvYu96utsY",
	"irLcWgVK+PioeMsDKkE44T7qjy9jcafFNaPcRglyes1wUn9qfj3N2d1F/2ltxEP5D4HYrPzEgRgDcF82",
	"ltKARY3dncuOz3qPeK54xoGUsSEWy18+TypqKbwX4Bans73mWFC0fLmTNLnYS4+Kq6fcSXsy2VyrPyBt",
	"PUSj69Vw+mhi6p0efGctqHdvRrQh0SupdIujaurP3BWkRnu+M1B93tk4U9qCdO0hjV66MbE9dvp0IwFH",
	"CDvevyjeBBXU4A3lki7cCyxs19GY0tc2DhE9pfHba+thHto1+NWM5xdp6dnB9LyNsur4ba1ioXNTWah7",
	"SicsCthq2voiPRXolbBdNtAqZreVhGnanWXgVuRFrIqFXV/nqzQqMUwtr7i0odSSJ2i+twHyPLleV0ob",
	"i5XTkqssIBcrXqZF4gJ3/31HyCrEQlCRpNpAVOLHD8QqJaQlLCqEqUq+pji2dmtez9mTaUTV/GkU4lIY",
	"MSsBW3xJLWbcoLDSmq5CF7c8kHZpsPnTHZova1loKOzSV58yijXaClp+mvCJGdgrAMmeYLsvv2OPMHDE",
	"iEt47HbRi6CTZ19+h2WR6I8naSKPxe42Ed0CqW4g+mk8xsgZGsOxTz9qmgpTudJx+r7hNlHXXe4StvQs",
	"YftdWnHJF5AOx1xtgYn64mmiF6u3L7KgAm4obDFh0/OD5Y4+ZUtulmn5gMBguVqthF35QAKjVg6f2hIz",
	"NGkYjqrBEYVv4AofMUqnYmm73sPamKhaS2rVGEv1D76C7rZOGTfM1A7m1l7mCeIJ81WWCqZkuY4smrg3",
	"bi4UUJywiXbnOau0kBY15trOs//F8iXXPHfk72QM3Gz27ddDkP+GpagYyFy5+eV+gD/4vmswoC/TW69H",
	"0D6IWr4veySVzFaOohSPPZXv3srRwKF0VHqg6P2khM1D7ypvuVGyUXSrO+jGI0p9J8STGwa8Iyo269kL",
	"H/de2YNjZq3T6MFrd0I/vXvjpYyV0tA1/M5CokhHXtFgtYBLDJBPH5Ib845nocudTuEu0H9ct38QOSOx",
	"LNzllCJAyZ7D7XA/x8seU7GVurgAqIRcnM5cHxLVadS+kL4ACUaYcQa6WDrMcZ8dy4ssIjg0m0Gp5MI8",
	"PKYHwEf8ygtAmvT65TaoBwOHYpEZNh3fGNfOTfE2FJekoV37j8GRmsjqrWnE73zb8UBox8YoleaFT3yh",
	"qJ+uB5bWe8XRTg6yILEOyd+SCzkSHQ1QjES+Ac54prQVFHsC8BHi2KxYgbF8VaXZLBqO6SbirXaANl2c",
	"NmIgV7IwzAiZA4NKmeW2fN2RPLNriZOVwhDLics+5kpT/T2UKazq5VLumumxMWu0C2OmlbJjgKLwEaf7",
	"KmUZr+0SpG0iqQErIfdXQrkgqHEQQyGSxX50ND5ULuRluZ4yYf9C42gfPsjZCvRFCcxqAHa1VAZYCfwS",
	"2qLkONpfDHt/LQqDJcdLuBa5WmheLUXOlC5An7BX3ruMWhB18vM9OWE+C85Hgr+/lri8QgGpSPE6aZkh",
	"oL/xZcQrnhID7f+MtaINlJdgTtj7K0VAmDZz2DghpNNjVlvKoCnEfA54T3E5qDxhv/ZDBBOWV8dg62ZY",
	"v6aPcNv6GJaZJX/6zbdjiPb0m29TuHb2w/On33zr5BAuGa+vRSm4XsfNXKspm9WitL7GKGeXkFulY9VQ",
	"SGOBFwPcIsOCnwV54byWuQ9VarrERfDPfnj+zZdP/+/Tb749Ya+bhEFMtyvXaBxCt9hbrdT8I3BPey0z",
	"1EtGlHdLFqJr+YIaMZ/u03XM9UjSiiwF4SKXUCxAT8mAjeguVtBm6DuZWWnbGsrmQFkwjqMIabUq6hwo",
	"L/ysQwcisMQApKYSdBRZgXc3vCrQwhmMXIGXnTB/VE9IvJWqu0K8M3AJmrIU2oEeEbGP4DKWawxJwQgV",
	"v1QoHqeZYl0tNC9gN38yMp+fqEeTzxxGuFT7DfCza98XVzsyYUfSSktHUcy/4+4xD03xkA23flQafjeW",
	"OfaKKvVrKCl5B4u8Y9vpQNadA2RGyLRBeg6A7JbnOVQO0+MnlgAc7yC9Aqk35hoHcccdvrTiEiitaIN8",
	"luW8zOuSQnQ3CF9XOS9117NVwtwqh3vxyxutlVa4uWYYIkzV0Wk+7XhS1AOLrFyCXvsWpNCGYuTu3uhe",
	"OMYwfS8r4RLSaiZwyuL7QV2xFZfr5izcFC0Y0yjXp4GcxEf09dNp/+R17Qh8umceITcD6Y5iZHOL+Jwr",
	"0EIVImdC/gb+ojcUK2AMvWqgpBWyxscgNLRwE+tmmJDYTzocYoAeK6vgPnTj+yVcdU67iETsbjS8sfwC",
	"COyQOumllV3PVIMRRT1iXdY870K2HzL6y/uOWzjVzdGaA+Flj3g1l3zTpevjcg9teqc13KVROtWhy7sQ",
	"K94kDzFPwxMBwr5eS2g5oo4qq4IRMNQraMa+BG26oaeRWRaut4ztWnTGpyo2WpHJZ/9ZshBZZEbnWxM5",
	"bnEuyMOUcIz9wYe2JHZwpMRPA4C5EjZfZiPZNq4ttaBspZ7yO5ySpAu8hTCfQ253gQHTNuhxj1Eo6LOD",
	"4iXwAnNg2wwcyr3pg/LoH4q5oU0k8kgjUDFoJR4c5fEeJVobDNmG/D+rHXH/UuH/0Gu9wzUIMo4/+7Ql",
	"mtp45GkTrjlbg8FdaQKJoztSKcPLtNMtTFpAydebpsQG3UkbmTf4HYnncMfDHEOhwOV0RHg0tb9nmyZ3",
	"TfoLbq7n8FbEjwf0T/L7S16OJAa9g0qDcbIk4+z998/fePfqWHpQPprNxq1PI7ecjVZ+uJmiLpQmERTB",
	"h9/9k2RJ0/JY1B4F7bnPg963i/YYq5AWbWgIAh0C9PeQo8AqLnzsQJsbNdxZny83zGDcJc+hPeD+InwW",
	"Gg6SWklcN28YoMKW+Jkq6rDwOsQQ+NHygsUsa0JwU8/DTCe+PGBcE21r3L0w2UosNBKd9KjjZQ0jA2ki",
	"j5GYXeKhMk9Yxrlhb987C+9B3ILXallh5tQZDaoVJw7KiFVVkt/bDzXIp98r168Nz7v/aM9Dh8rde7Ab",
	"3NrnevgYt9vCsr1iwObItn/KF2pVlTDODyqKWKD3+ohzYo2U6GW2YIVReV7r1izaj137mZeCngwyWCdF",
	"KlVhYZTKCun+g2lzqrb0f+Da/YeqdnX/R1gVlU9xQ03wXLBSQRgoRMVPHMsuSGHwfVPlVW6ZeruTPX/I",
	"axIUcWM8fofH48mU5IVocwzcrcQvC/wSpzIwAgTjZ0z4y7ACLOiVk12X6oqt6nyJ0ft8ASGYH42jaMvu",
	"TdQZPcQ3dpNSvD/YVDyngShmrOR6AZr5MC7mi5U3sWArLnpvsfUjNVCV5Sn+uy3FYPgGIUpLUaJBIpMh",
	"gHEB61MSBvD3WxCO8XyFEcAwa+EeQbpT8kOcP7MFXy86chSV4OukHDXgH1CecvD5u7anPDXMDNp1ebgO",
	"vA61geE6d/f/xXubIBXt2nZVBoabOy7D29kuMny6lpbrjkoEbQjWt2MIKvv3l/9mGub+CdgvvsAJvvhi",
	"6pv++2n3s0O8L75Ia2APpT7QHvkx/LxJjOkWee4/kIsEzWCxIP+Cba5WKyXR0FSWPcerLBiGohl80lYy",
	"kJdQqgqSrWmDo0PHlCMNi7rk5HAUUoLudNolltyIhYTCXksKUjnDP99fy1TbmNVj62g7UkWAo7d5blcd",
	"u1ftkSL56TH4247YRt23I1J07l1GfEWhwc2IONQc9F3GfO/H2KHw6kJqSrGk2HgRIsVQSKMT7r1aGaLH",
	"QkHWEAPfONXh95qXPmhAoov+PcaB5xcgqdZq8wy/VQykqbX30TtYcTwHih9GxQzetE1uW3U121TJUKOx",
	"vLHD+8hAzGmgrk70KNzhqM11wlx7IRfZhvSnHPOffMOQ34oWro1FNd3gDgn1Cood6xrE/jDM8Qv9R4Zv",
	"C3i1D2Sls9+iV3PlsAoIe/T65WOGJX7Giq1Ej6BuX3ZcQ2w3iCjcdABLP9txHyjmAGNOyF54A5vDiD17",
	"W6Wq+WVbpApb9Q3HW6HcMTbwB26w6pRv7n3pn2hAYAdI/wLqcKg4O3vvSkbTyUKrOh0/tqCKAb3IVlQM",
	"UOiiyBOz5N98+fT06TffskIswNgT9i9M3yLmO6xP2T1NJtq6l53yugwBa1KCSR7yIRTRnEt/oIMQJeFD",
	"KXCYhz/h2xTQmE5QLsnsdSrM7vVAZmGVjzvBbNaI3nSM9YcIrhPSak7EN1PzeTLD+5/4e2tK0oEmaxie",
	"+g5Umd4YvqVU8Hd6oPhmOtlSMq68bKrF3Y7wlDBWvLi8Tlyfr55m7Q06YW9cbwZyrrTTtFe1dTIAXGOm",
	"F9k6O1Iqpj/ZtpA7Zj7JP0ArNCRIpmQOAx4oos3G2BCeozxvfOyTg6FJ5W4SAx6doTQzJSAfk546vGqs",
	"llaQ+OO28edoFyvHeBzQ/1qKMoEFlXLfTQzHlEnF6ImSuCUFV7ZpfASzD53vINLDXvO4nEWRtpM5TCio",
	"NFBbBaq1UuRLLts3F7bXDBri5D5vKXdpf/+aH7K20QY4P25xI6lGglqkr+DoFBRMqGssag8LcMXXK5D2",
	"lpTvLfWmeBmsOa43awB6RAMIvbdVcL+AdWZVemz3sUnoblQttJ0StY3WOB3Re5rIgPBaRSu70g1yIsK8",
	"xnDMKHI42E69StfY4C9gzXQwDcTFckltuoWWRWzRilTC2XuxglYvIUEuJQKJnVgiqZdpvZZyIIhk/2XD",
	"cpphNmOFGcEK6rsZJ5pT2ANtz5o+GPGbjVvS1hV0wwc6Beq7obSo45+wl01oOfpaKKKvjTcn+1PfI0Nx",
	"1E2+vNDBTsV1sDmj0+b8/JeKoikSF9c3IFnGtRlKNb4Jz+eL5pmbhOEmNLueg27bpYwnoeVc/9E2HNpt",
	"QrPhC0kdytO6lCq+ngSxbDKdOIDdPw4g9+9c/zHBR4HKoSspfYf8MWc4QSI2btJVHDuyXHMZWmzZYoTc",
	"WIHVR/yg0yZibPtaCGO7NtWcaH94wcvy/bWkmRIBKP5p/xGXIxU19uk1DZF0lNR7HYPhyF/Q2EHC89xJ",
	"WUUbKxrB+RfD+qWzKIJ0WDyrw8T3JJKJR6wadON6MbputBkNJUGRM64X9Yps+ve/vi0rGC0YKwqf2Tes",
	"euqlJrrptYaCKe1zesTcJ2yNle3ZsZQhPf71Ri1E3kpnbfjqCKZPnf4BlS+goWSWNw5xx6qckmcVOydH",
	"8vkEc0acJK6BF0QztbCQKqrXWT8mI18BPhYQMDprTjcqmXriblGnaKFBzNaAb3wlymh+rmUaeWXqkRMb",
	"o0ok2HQP6SOc0As3U1senw4p51Iq+xmd055lGnuvHEbhH1XV1GssQYbHNkn0xWFHzKRKg1jITS+TzXlg",
	"BKZ/XEl20KVSPu8wPngz4BKNRHw7IorODxqMHiDiRaZkuU5R1zjHtEdem73Y+DxZk3Vq2pAh41cZFTja",
	"bYmBzLyNVoiIHdLfDrm+W1TVvHMpzd4AHaqxrW8nLipRfDPmhf2ht0lmkaNxo2RG1XZKt3CiTxqywD8D",
	"xZIFFeKp2zCrc/mc/QFaeX2xGcpdiNY87asx+ETpk0SnpmqWGXTrT7lnVTJa/AbpcLTa3/n5L9d8IGUg",
	"THeQL25XuHHrGb8aqQoVn3HwVvkyUHcs90YzbtjYscd3z89/mfOi6BXIiUOviMg0BV5ot315LEQWfjVS",
	"iWrjac43nuaG8TupG1dB4dvwQFpQEClJ5irsOPVIhaOOh1a2ZQOHU+9y+Rv//U6oEZTeuyJHmHUDemwo",
	"5slXqJM9b+o0e+BUA98J8yTE+7rD7zqYUsp5oGbBPRYcuL0X6p4TX1vx6qClQrcSjwjicbc/jDr924So",
	"8HaaHy8qv4EDtNEF/Xfw7vbgZhg9fYL4tZ8Gw+PaPO3buxpWmMPVqpiJw/E1/RqxsC22SIEUGPcQh4ab",
	"aIZ4rxl77Ubm5RVfm2AqbRFrfLiwq1TEJ2Gmi5M8yb6b3hudo2PsHeSiEviccJcKNjg+bmAcec6ZDJWO",
	"6FD2mbhsjBY+Npy3VTK7zq/g+/L1/njEoKd+m3nZtRbQwMEY7Nq8CGOHFTVHGvGz7YkQqZqpzZZuoXne",
	"O7mR2HlL4b40jnoRkaNpxqmb7L/tNOIWka6RO7Qfub7o8EBuuk+pUhJEZ9SOiBGlLtzitTnvTHjbPqeF",
	"odiNaf9n0OTAfMdloVbsVah78ejnd68eMw2mLm1AslARwSGfh+QTfYiu0nO/8rPe83MhEp18GgthrE7Y",
	"LT/dx+nmw8fpEk+0udUd6lm6i+IjPUtXDp6lu/1Kd3+QLtyYsefoPkkE2qJJBAfnZurpfTH7kk/fjein",
	"n+l24iFJh23yQlRAwJ1nKEHWY/x3ErI6z09zy66c9GHi92gTQZ1tQWfZxGZGfoStQZ/d8UZen/FyFk6C",
	"dSgTrxYb/xp24C2tZOQfD6NC1GUk/MxrWZjeFrYPomzwgG6UfbzoE9psdKaOCQW7SgJnsau0Cwm6In0q",
	"SPPqdv/NIywOTGWA8eVzenS7X9mr3cpKq0tRpJ4iKdVC5IYsMPv6bN+EvjfTyaourbjlOD+GvuRETrND",
	"sfCsUBZcFwyKp9988+V37XI/MXI13KRkgI1fljcycivyrhzbrG4HIhaO8mShhiRr1NemF63rofGtTbGc",
	"eRu/tp+LDAFJrzdabAjRmK0Zj1BdObG9tKL9aep+W3KzbElnVJIenwrgzNOrftwdZv18nDevokuR3Sk0",
	"onc9xghHe0k+hbvRexJO5DuTxB8jSjKs2O6XSGZXhy8hFRL3uirByXYtDRzem1yvK6tOw9EQyw9znonh",
	"yy7xeOldxwZYglY5SYQKJDhhspW40EDQQnWL+NzB/pzFcKUqYy41GAdROp5mqc/Pf00Lm2NVA5x0me50",
	"s+fZnvX2tLvjtG+jEm51QUA8sM62GQceHqThnt9gyPYcpbFcSctzlBupJvrkuTeYTXwJ7snS2so8Oz29",
	"uro6Cda0k1ytTheYdpJZVefL0zAQPU4VJ4L7Lr6IoqPC5dqK3LDnb1+jzCRsCRjBXsA1Wu0azJo8PXlC",
	"9QNA8kpMnk2+Only8iXt2BKR4JRqdUyefbiZTk4vn57GoTKL5FtjwHW+JEXAtz3BXHgg7eZ10TR6pfTz",
	"MJx3e9Bry89+GXtXyV1Z9/fvNej1JDxsEJuBWmfc8Hpsz3ImM4WhEExba8ob18DyIMRFnmZ6DRAuQTJB",
	"Yl8pVqJ5z0Q7pdZz7QTM2HZPgNuSWnwBEbwn7CcDUUlLdYFJICRuhpDyUJGx6TQCmBsiBVeL8sMUX9o1",
	"L+pihB+XwfK+wLQndJrIKHT0pFMTzptqQ1VUKtmRr1ktSydfBPcDeg1NszQsF0jVLHLud8DnW4W4VTN+",
	"AmGSzEOYOQj3PBFf7B51I2QmPtIWrVxedfI4Pm3Kj8RxA9P2nThvqJ+ypqBHz8I89X7/8Az08HVliioY",
	"W7APAs54WaaWGfma+sv8/tovs8V+Wq2p8yVGqPQBHbz7jE+i+HIB7ZtHtDdT3z+KGgjJck20QNNSdjZw",
	"hz5uO+C6KlUBk2dzXhpIbw/QIjtb0wgIIRCT9s4HRvTSBA3FYJosig6YdFIcXQupZLrgR192MHaNpNvx",
	"s8m+t670r1N9olfOTXGn+xaiMCMXu3+SCteLdVfdJbyA9RgwbbLyOLXbGlu5+fMY+IHPhMiG9oEhKl+J",
	"dcYr0DikzNG5YpBaBMsl4XwIrimE4bMS39wgs0QnMmOUIDTlePc4gbj0zDhD7sekbJjhV3wnB4uA4U17",
	"+uRJkJ28qTEa7fQ3Q0JxO+B4LO8+yTmpCxgqGm5MfG7qVJMPjM71imSGVVXb8TiBa5shpx6O/JPxRLLi",
	"CyF9dA0a8Fb8Au10ktK0fHBbuJ0hz92x/8Yz4wUGjzE72NFamay7Ab8mZd0u5I8wyOWxW+DXdzrH0epv",
	"41XYeusIDXcB+51HQArQpepxN9PJN5/7EhxS84WTqCcGZe7Jrzc9Sf70Q4guFcXNqFj/RqmLumrsw/Hj",
	"MgPpntr6e/W3NRKJjdJ9Y3UONBdJilNCIorSADmJ98jqGvaSVXelwAekmEcZ8SgjPoyMeC+sdA8Geo8M",
	"M82kjjxq8vWTr49s9tNhsyUyvy1s9nRAAbbxXRnFvPXpqKqI3Pr3YnibpkVlSzZw5+dVhZnxGNxiPiU+",
	"fXA148/Klo9GzlsZOQ/MSnv3fQ/1tJ2lvalHZTVKfult7FEiOEoEn6NE0KTafRQ5IKgmnw7/vxeP35Hn",
	"H3n+g/H85kbvxujjxxiO/D3w98aIcmTqR6b+uTH1RHHb/Vh8sFamjZl3YvkvaOjnMWhH/f8oCxxlgfvR",
	"/zsEYF/V/ygQJKpdHMWCo1jweYsF++v8jUDQ84UeRBQ4GgGOjP/I+D+6EeDI7I/a/5HNf/5sPs4L3TWw",
	"rltz5X3nHS4NnmxDwSRcuctmFVOlY0ZbOHw80DYGf+Qbh8mKiR4HcrPMxbWnzqEgTq56D0tKfHZcQDm6",
	"PRJLUOBgewetUzLxWMx68/VDcuJQ5zme9AC1qVPbJhbv15XbhxID9n5zuxUwsG5LJDTxmqH6eJMbiJXB",
	"jViwrMlUd7+s6CfMfjwTC/dTST9h3jVlnabWbsRifPEGu63oHzfeTov0tz5aSDflfLb2Unv6LNIi7ycZ",
	"9Bqm5JY5rWROmWDx1Cshs43TNw0OAsIM5sqnvkQw8OstMIQG+2ZL3KsGE1YWrWkhHOW1YgUn7EdPaLhk",
	"7169YF999dV3jC6802gIXcYWTEPSywoxcA3BKLhtPu9Cft69eoEAnDWxrDu12nqoDUYdauU44qe38D9x",
	"kuWfMtPtYyZF0Kq96cFrk/TUzGbxpHmQZqOl4rAa9p9EM55O+urE3d+W62lI3Z3sTXhM/vqPUlh3cUjH",
	"pRy6Xpexag57+JLv37/7ChUI0h86lfqbS0cSQ1OvtS00liTo1Ox2gvfR1Hw0GRx9zH9GH/N/dApxtE+n",
	"H7rEensqcfRc15jxsm2STiNOicR9lrFVLP7TeQrvjezsSWweLlv0ju6jo+/lMxFlB0ToNLyquyMlYq79",
	"DuTojVqYj0OSjqLWYbwzH9kC/yc1h2Od5MauNHhKj0o3+eLXm9Ux/45u+w7O/VRwujdeOf5sZSWK696j",
	"sEzIAq5H6oDfp4heqkUWyP/+6aqLlzz91vnnIPkTqb6D5LCJZ20O/IsNL9hyUwXNnYL2jnaII3Pcg1t1",
	"TGf+WceHM5ptn92NPrpa3nPcHWC+Wgo7Np/7Nnn4qNZjmOIxTPGoZz6ksQsP+fRDuJ7bDVz+OcHtlfJc",
	"w921yfjJs6Np615NW0jmdqWFD1j8DKc8kpujZe7Ttsz1KebpjJdc5rDVIkeit6GXXUOl56ulQoLi6zYi",
	"gdlIUcNkR93oqBsdHzs4xuHtGod3MKHrsNJITDx30tJ+FFIcq8qkuN6sZQ1Hle3PJIDsk5LVcU/Eb+Bv",
	"ysuibCzHUilDa6POd8zKOmZlHbOyjllZx6ysB3ZDH/OnjvlTR73tPzt/apdQk/B8sZDx490xyUe+Pyp+",
	"3Hf0yWBRL9RqJiS0mk9YQfsimFXuoLARvu7u+XBoaBUzTXjBlnVlWpUj/BWjb+K31qeTuQb4AzLLtZOq",
	"d+G3ndUEAPHtlmj++PGWvdbmpGGytLGQt0a4LN0+l+Wa2aaYEuPNk/NTJyCvVc2u8LKU4gL7+4df3Kav",
	"mEPi3kNsVjGr61GvtO+e0av92zLkpg/h+Tkm+x2T/Y7Jfn8CM8isVPmFOf2AR52RAWGr9xo7jVkv/uY+",
	"brNY0GWk6dLpyzFAD2tZ3XSLaHHHnIDPGON3MvNFUZa7Vl3qW/eCBJyWxIRBCbcvBzea1371nJqIz6PV",
	"8Gg1PFoNj1bDo9XwWMvpaIs82iKPtsijLfJoizzaIu/PFvkx7Yf3/zDM0UJ5tFAe7TUfNbcmPtrTD04n",
	"2p5dw5z6WHY45Ji5Msa6XVJsvFK2e0HFz4iERNu112Xd/XIeE1GO5OVTMQffTCcG9GW467UuJ88mS2sr",
	"8+z0FK75qirhJFerU6z04Pt/aOR+tVoho2p+8SNHv3hSdvPrzf8PAAD//2iyvOFWTAEA",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
