// Package generated provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"net/http"
	"strings"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (GET /v2/accounts)
	SearchForAccounts(ctx echo.Context, params SearchForAccountsParams) error

	// (GET /v2/accounts/{account-id})
	LookupAccountByID(ctx echo.Context, accountId string, params LookupAccountByIDParams) error

	// (GET /v2/accounts/{account-id}/apps-local-state)
	LookupAccountAppLocalStates(ctx echo.Context, accountId string, params LookupAccountAppLocalStatesParams) error

	// (GET /v2/accounts/{account-id}/assets)
	LookupAccountAssets(ctx echo.Context, accountId string, params LookupAccountAssetsParams) error

	// (GET /v2/accounts/{account-id}/created-applications)
	LookupAccountCreatedApplications(ctx echo.Context, accountId string, params LookupAccountCreatedApplicationsParams) error

	// (GET /v2/accounts/{account-id}/created-assets)
	LookupAccountCreatedAssets(ctx echo.Context, accountId string, params LookupAccountCreatedAssetsParams) error

	// (GET /v2/accounts/{account-id}/transactions)
	LookupAccountTransactions(ctx echo.Context, accountId string, params LookupAccountTransactionsParams) error

	// (GET /v2/applications)
	SearchForApplications(ctx echo.Context, params SearchForApplicationsParams) error

	// (GET /v2/applications/{application-id})
	LookupApplicationByID(ctx echo.Context, applicationId uint64, params LookupApplicationByIDParams) error

	// (GET /v2/applications/{application-id}/logs)
	LookupApplicationLogsByID(ctx echo.Context, applicationId uint64, params LookupApplicationLogsByIDParams) error

	// (GET /v2/assets)
	SearchForAssets(ctx echo.Context, params SearchForAssetsParams) error

	// (GET /v2/assets/{asset-id})
	LookupAssetByID(ctx echo.Context, assetId uint64, params LookupAssetByIDParams) error

	// (GET /v2/assets/{asset-id}/balances)
	LookupAssetBalances(ctx echo.Context, assetId uint64, params LookupAssetBalancesParams) error

	// (GET /v2/assets/{asset-id}/transactions)
	LookupAssetTransactions(ctx echo.Context, assetId uint64, params LookupAssetTransactionsParams) error

	// (GET /v2/blocks/{round-number})
	LookupBlock(ctx echo.Context, roundNumber uint64) error

	// (GET /v2/transactions)
	SearchForTransactions(ctx echo.Context, params SearchForTransactionsParams) error

	// (GET /v2/transactions/{txid})
	LookupTransaction(ctx echo.Context, txid string) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// SearchForAccounts converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAccounts(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"asset-id":              true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"include-all":           true,
		"exclude":               true,
		"currency-less-than":    true,
		"auth-addr":             true,
		"round":                 true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAccountsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "auth-addr" -------------
	if paramValue := ctx.QueryParam("auth-addr"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "auth-addr", ctx.QueryParams(), &params.AuthAddr)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter auth-addr: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAccounts(ctx, params)
	return err
}

// LookupAccountByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"round":       true,
		"include-all": true,
		"exclude":     true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountByIDParams
	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------
	if paramValue := ctx.QueryParam("exclude"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", false, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountByID(ctx, accountId, params)
	return err
}

// LookupAccountAppLocalStates converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAppLocalStates(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAppLocalStatesParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAppLocalStates(ctx, accountId, params)
	return err
}

// LookupAccountAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountAssets(ctx, accountId, params)
	return err
}

// LookupAccountCreatedApplications converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedApplications(ctx, accountId, params)
	return err
}

// LookupAccountCreatedAssets converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountCreatedAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"asset-id":    true,
		"include-all": true,
		"limit":       true,
		"next":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountCreatedAssetsParams
	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountCreatedAssets(ctx, accountId, params)
	return err
}

// LookupAccountTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAccountTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "account-id" -------------
	var accountId string

	err = runtime.BindStyledParameter("simple", false, "account-id", ctx.Param("account-id"), &accountId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter account-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAccountTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAccountTransactions(ctx, accountId, params)
	return err
}

// SearchForApplications converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForApplications(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"application-id": true,
		"creator":        true,
		"include-all":    true,
		"limit":          true,
		"next":           true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForApplicationsParams
	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForApplications(ctx, params)
	return err
}

// LookupApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationByID(ctx, applicationId, params)
	return err
}

// LookupApplicationLogsByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupApplicationLogsByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":         true,
		"limit":          true,
		"next":           true,
		"txid":           true,
		"min-round":      true,
		"max-round":      true,
		"sender-address": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameter("simple", false, "application-id", ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupApplicationLogsByIDParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "sender-address" -------------
	if paramValue := ctx.QueryParam("sender-address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sender-address", ctx.QueryParams(), &params.SenderAddress)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sender-address: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupApplicationLogsByID(ctx, applicationId, params)
	return err
}

// SearchForAssets converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForAssets(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
		"limit":       true,
		"next":        true,
		"creator":     true,
		"name":        true,
		"unit":        true,
		"asset-id":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForAssetsParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "creator" -------------
	if paramValue := ctx.QueryParam("creator"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "creator", ctx.QueryParams(), &params.Creator)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter creator: %s", err))
	}

	// ------------- Optional query parameter "name" -------------
	if paramValue := ctx.QueryParam("name"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "unit" -------------
	if paramValue := ctx.QueryParam("unit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "unit", ctx.QueryParams(), &params.Unit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unit: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForAssets(ctx, params)
	return err
}

// LookupAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetByID(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":      true,
		"include-all": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetByIDParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetByID(ctx, assetId, params)
	return err
}

// LookupAssetBalances converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetBalances(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"include-all":           true,
		"limit":                 true,
		"next":                  true,
		"currency-greater-than": true,
		"currency-less-than":    true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetBalancesParams
	// ------------- Optional query parameter "include-all" -------------
	if paramValue := ctx.QueryParam("include-all"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "include-all", ctx.QueryParams(), &params.IncludeAll)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter include-all: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetBalances(ctx, assetId, params)
	return err
}

// LookupAssetTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) LookupAssetTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameter("simple", false, "asset-id", ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params LookupAssetTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupAssetTransactions(ctx, assetId, params)
	return err
}

// LookupBlock converts echo context to params.
func (w *ServerInterfaceWrapper) LookupBlock(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "round-number" -------------
	var roundNumber uint64

	err = runtime.BindStyledParameter("simple", false, "round-number", ctx.Param("round-number"), &roundNumber)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round-number: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupBlock(ctx, roundNumber)
	return err
}

// SearchForTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) SearchForTransactions(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty":                true,
		"limit":                 true,
		"next":                  true,
		"note-prefix":           true,
		"tx-type":               true,
		"sig-type":              true,
		"txid":                  true,
		"round":                 true,
		"min-round":             true,
		"max-round":             true,
		"asset-id":              true,
		"before-time":           true,
		"after-time":            true,
		"currency-greater-than": true,
		"currency-less-than":    true,
		"address":               true,
		"address-role":          true,
		"exclude-close-to":      true,
		"rekey-to":              true,
		"application-id":        true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchForTransactionsParams
	// ------------- Optional query parameter "limit" -------------
	if paramValue := ctx.QueryParam("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// ------------- Optional query parameter "next" -------------
	if paramValue := ctx.QueryParam("next"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "next", ctx.QueryParams(), &params.Next)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter next: %s", err))
	}

	// ------------- Optional query parameter "note-prefix" -------------
	if paramValue := ctx.QueryParam("note-prefix"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "note-prefix", ctx.QueryParams(), &params.NotePrefix)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter note-prefix: %s", err))
	}

	// ------------- Optional query parameter "tx-type" -------------
	if paramValue := ctx.QueryParam("tx-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "tx-type", ctx.QueryParams(), &params.TxType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tx-type: %s", err))
	}

	// ------------- Optional query parameter "sig-type" -------------
	if paramValue := ctx.QueryParam("sig-type"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "sig-type", ctx.QueryParams(), &params.SigType)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sig-type: %s", err))
	}

	// ------------- Optional query parameter "txid" -------------
	if paramValue := ctx.QueryParam("txid"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "txid", ctx.QueryParams(), &params.Txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// ------------- Optional query parameter "round" -------------
	if paramValue := ctx.QueryParam("round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "round", ctx.QueryParams(), &params.Round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Optional query parameter "min-round" -------------
	if paramValue := ctx.QueryParam("min-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "min-round", ctx.QueryParams(), &params.MinRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter min-round: %s", err))
	}

	// ------------- Optional query parameter "max-round" -------------
	if paramValue := ctx.QueryParam("max-round"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "max-round", ctx.QueryParams(), &params.MaxRound)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max-round: %s", err))
	}

	// ------------- Optional query parameter "asset-id" -------------
	if paramValue := ctx.QueryParam("asset-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "asset-id", ctx.QueryParams(), &params.AssetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	// ------------- Optional query parameter "before-time" -------------
	if paramValue := ctx.QueryParam("before-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "before-time", ctx.QueryParams(), &params.BeforeTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before-time: %s", err))
	}

	// ------------- Optional query parameter "after-time" -------------
	if paramValue := ctx.QueryParam("after-time"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "after-time", ctx.QueryParams(), &params.AfterTime)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after-time: %s", err))
	}

	// ------------- Optional query parameter "currency-greater-than" -------------
	if paramValue := ctx.QueryParam("currency-greater-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-greater-than", ctx.QueryParams(), &params.CurrencyGreaterThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-greater-than: %s", err))
	}

	// ------------- Optional query parameter "currency-less-than" -------------
	if paramValue := ctx.QueryParam("currency-less-than"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "currency-less-than", ctx.QueryParams(), &params.CurrencyLessThan)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter currency-less-than: %s", err))
	}

	// ------------- Optional query parameter "address" -------------
	if paramValue := ctx.QueryParam("address"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address", ctx.QueryParams(), &params.Address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Optional query parameter "address-role" -------------
	if paramValue := ctx.QueryParam("address-role"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "address-role", ctx.QueryParams(), &params.AddressRole)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address-role: %s", err))
	}

	// ------------- Optional query parameter "exclude-close-to" -------------
	if paramValue := ctx.QueryParam("exclude-close-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "exclude-close-to", ctx.QueryParams(), &params.ExcludeCloseTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude-close-to: %s", err))
	}

	// ------------- Optional query parameter "rekey-to" -------------
	if paramValue := ctx.QueryParam("rekey-to"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "rekey-to", ctx.QueryParams(), &params.RekeyTo)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter rekey-to: %s", err))
	}

	// ------------- Optional query parameter "application-id" -------------
	if paramValue := ctx.QueryParam("application-id"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "application-id", ctx.QueryParams(), &params.ApplicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchForTransactions(ctx, params)
	return err
}

// LookupTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) LookupTransaction(ctx echo.Context) error {

	validQueryParams := map[string]bool{
		"pretty": true,
	}

	// Check for unknown query parameters.
	for name, _ := range ctx.QueryParams() {
		if _, ok := validQueryParams[name]; !ok {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Unknown parameter detected: %s", name))
		}
	}

	var err error
	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameter("simple", false, "txid", ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.LookupTransaction(ctx, txid)
	return err
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}, si ServerInterface, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET("/v2/accounts", wrapper.SearchForAccounts, m...)
	router.GET("/v2/accounts/:account-id", wrapper.LookupAccountByID, m...)
	router.GET("/v2/accounts/:account-id/apps-local-state", wrapper.LookupAccountAppLocalStates, m...)
	router.GET("/v2/accounts/:account-id/assets", wrapper.LookupAccountAssets, m...)
	router.GET("/v2/accounts/:account-id/created-applications", wrapper.LookupAccountCreatedApplications, m...)
	router.GET("/v2/accounts/:account-id/created-assets", wrapper.LookupAccountCreatedAssets, m...)
	router.GET("/v2/accounts/:account-id/transactions", wrapper.LookupAccountTransactions, m...)
	router.GET("/v2/applications", wrapper.SearchForApplications, m...)
	router.GET("/v2/applications/:application-id", wrapper.LookupApplicationByID, m...)
	router.GET("/v2/applications/:application-id/logs", wrapper.LookupApplicationLogsByID, m...)
	router.GET("/v2/assets", wrapper.SearchForAssets, m...)
	router.GET("/v2/assets/:asset-id", wrapper.LookupAssetByID, m...)
	router.GET("/v2/assets/:asset-id/balances", wrapper.LookupAssetBalances, m...)
	router.GET("/v2/assets/:asset-id/transactions", wrapper.LookupAssetTransactions, m...)
	router.GET("/v2/blocks/:round-number", wrapper.LookupBlock, m...)
	router.GET("/v2/transactions", wrapper.SearchForTransactions, m...)
	router.GET("/v2/transactions/:txid", wrapper.LookupTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AQA=",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}
